package main

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/jsageryd/markov/markov"
)

func main() {
	scbFirstNamesFemaleState := generateChainState("_generate/data/scb-firstnames-female-1999-2017.txt")
	scbFirstNamesMaleState := generateChainState("_generate/data/scb-firstnames-male-1999-2017.txt")
	scbLastNamesState := generateChainState("_generate/data/scb-lastnames-1999-2017.txt")

	src := []byte(`
// generated by go generate; DO NOT EDIT

package namegen

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/jsageryd/markov/markov"
)

const (
	scbFirstNamesFemaleState = "` + string(scbFirstNamesFemaleState) + `"
	scbFirstNamesMaleState   = "` + string(scbFirstNamesMaleState) + `"
	scbLastNamesState        = "` + string(scbLastNamesState) + `"
)

var (
	scbFirstNamesFemale *markov.StringsChain
	scbFirstNamesMale   *markov.StringsChain
	scbLastNames        *markov.StringsChain
)

func init() {
	newChain := func(r io.Reader) *markov.StringsChain {
		newSeed := func() int64 {
			var seed int64
			binary.Read(rand.Reader, binary.BigEndian, &seed)
			return seed
		}
		chain := markov.NewStringsChain(2, newSeed())
		if err := chain.ImportState(base64.NewDecoder(base64.RawStdEncoding, r)); err != nil {
			panic(fmt.Sprintf("error importing chain state: %v", err))
		}
		return chain
	}

	scbFirstNamesFemale = newChain(strings.NewReader(scbFirstNamesFemaleState))
	scbFirstNamesMale = newChain(strings.NewReader(scbFirstNamesMaleState))
	scbLastNames = newChain(strings.NewReader(scbLastNamesState))
}
`)

	b, err := format.Source(src)
	if err != nil {
		log.Fatal(err)
	}

	if err := ioutil.WriteFile("gen.go", b, 0644); err != nil {
		log.Fatal(err)
	}
}

func generateChainState(filename string) []byte {
	f, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	c := markov.NewStringsChain(2, 0)

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		c.Feed(strings.Split(scanner.Text(), ""))
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	var buf bytes.Buffer

	base64Enc := base64.NewEncoder(base64.RawStdEncoding, &buf)
	if err := c.ExportState(base64Enc); err != nil {
		log.Fatal(err)
	}
	base64Enc.Close()

	return buf.Bytes()
}
